# 하루 한 문장 - 백엔드 설계서

## 📋 목차
1. [아키텍처 개요](#아키텍처-개요)
2. [데이터베이스 설계](#데이터베이스-설계)
3. [API 설계](#api-설계)
4. [비즈니스 로직](#비즈니스-로직)
5. [스케줄링 시스템](#스케줄링-시스템)
6. [성능 최적화](#성능-최적화)
7. [에러 처리](#에러-처리)
8. [테스트 전략](#테스트-전략)

---

## 아키텍처 개요

### 🏗️ Firebase Functions 기반 서버리스
```
📱 Frontend → 🌐 API Gateway → ⚡ Cloud Functions → 🗄️ Firestore
                                    ↓
                               ⏰ Schedulers
```

**선택 이유:**
- 서버 관리 불필요
- 자동 스케일링
- Google 생태계 통합
- 비용 효율성

### 📦 레이어드 아키텍처
```typescript
// functions/src/index.ts
export const api = onRequest(require('./api/router'));
export const selectDailyQuote = onSchedule('0 0 * * *',
  require('./schedulers/dailyQuoteSelector'));
```

---

## 데이터베이스 설계

### 🗄️ Firestore 컬렉션 구조
```typescript
// quotes 컬렉션
interface Quote {
  id: string;
  type: 'quote' | 'text';
  content: string;
  like_count: number;
  last_shown_date: string;
  status: 'published' | 'hidden';
  created_at: Timestamp;
  updated_at: Timestamp;
}

// submissions 컬렉션
interface Submission {
  content: string;
  status: 'pending' | 'approved' | 'rejected';
  created_at: Timestamp;
  user_ip?: string;
}

// daily_quotes 컬렉션
interface DailyQuote {
  date: string; // 문서 ID
  quote_id: string;
  selected_at: Timestamp;
}
```

### 🔒 보안 규칙
```javascript
// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /quotes/{quoteId} {
      allow read: if resource.data.status == 'published';
      allow write: if isAdmin();
    }

    match /submissions/{submissionId} {
      allow create: if isValidSubmission(request.resource.data);
      allow read, update, delete: if isAdmin();
    }
  }
}
```

### 📊 인덱스 최적화
```json
// firestore.indexes.json
{
  "indexes": [
    {
      "collectionGroup": "quotes",
      "fields": [
        {"fieldPath": "status", "order": "ASCENDING"},
        {"fieldPath": "last_shown_date", "order": "ASCENDING"}
      ]
    }
  ]
}
```

---

## API 설계

### 🌐 RESTful 엔드포인트
```typescript
// API 구조
GET  /v1/quotes/today     # 오늘의 글 조회
GET  /v1/quotes/random    # 랜덤 글 조회
POST /v1/quotes/:id/like  # 글 공감하기
POST /v1/submissions      # 글 제출
GET  /v1/health          # 헬스체크
```

### 📡 API 응답 형식
```typescript
// 성공 응답
{
  "data": {
    "id": "quote_123",
    "content": "가장 어두운 밤도 곧 끝날 것이다.",
    "like_count": 42
  },
  "timestamp": "2024-09-24T12:00:00Z"
}

// 에러 응답
{
  "error": "QUOTE_NOT_FOUND",
  "message": "글을 찾을 수 없습니다",
  "timestamp": "2024-09-24T12:00:00Z"
}
```

### 🛡️ 미들웨어 체인
```typescript
// api/router.ts
router.use(corsHandler);
router.use(rateLimiter);
router.use(validateRequest);
router.use(cacheMiddleware);
router.use(errorHandler);
```

---

## 비즈니스 로직

### 📋 서비스 레이어 구조
```
services/
├── QuoteService.ts      # 글 관련 로직
├── SubmissionService.ts # 제출 관련 로직
├── CacheService.ts      # 캐싱 로직
└── AnalyticsService.ts  # 분석 로직
```

### 🎯 핵심 비즈니스 규칙
```typescript
class QuoteService {
  // 1. 오늘의 글 조회 (캐시 우선)
  async getTodaysQuote(): Promise<Quote | null> {
    // L1: 메모리 캐시 → L2: Redis → L3: DB
    const cached = await this.cacheService.get(`daily-${today}`);
    if (cached) return cached;

    const dailyQuote = await this.repository.getDailyQuote(today);
    if (!dailyQuote) {
      await this.selectDailyQuote(); // 자동 선정
    }

    return await this.repository.getById(dailyQuote.quote_id);
  }

  // 2. 공감하기 (중복 방지)
  async incrementLike(quoteId: string, userIp: string) {
    const likeKey = `like-${quoteId}-${this.hashIP(userIp)}`;
    const lastLike = await this.cacheService.get(likeKey);

    if (this.isWithin24Hours(lastLike)) {
      return { success: false, error: 'LIKE_TOO_SOON' };
    }

    const result = await this.repository.incrementLikeCount(quoteId);
    await this.cacheService.set(likeKey, new Date(), 86400); // 24시간

    return { success: true, like_count: result.like_count };
  }
}
```

### 🎲 글 선정 알고리즘
```typescript
// 가중치 기반 랜덤 선택
selectQuoteWithWeights(quotes: Quote[]): Quote {
  const weights = quotes.map(quote => {
    let weight = 1;
    weight += Math.max(0, 50 - quote.like_count) * 0.1; // 좋아요 적으면 가중치 증가
    weight += this.getDaysSince(quote.last_shown_date) * 0.05; // 오래될수록 가중치 증가
    return weight;
  });

  return this.weightedRandom(quotes, weights);
}
```

---

## 스케줄링 시스템

### ⏰ 일일 글 선정 스케줄러
```typescript
// schedulers/dailyQuoteSelector.ts
export const selectDailyQuote = onSchedule({
  schedule: '0 0 * * *', // 매일 자정
  timeZone: 'Asia/Seoul'
}, async (event) => {
  try {
    const today = new Date().toISOString().split('T')[0];

    // 멱등성 체크
    const existing = await getDailyQuote(today);
    if (existing) {
      console.log(`Already selected: ${existing.quote_id}`);
      return;
    }

    // 100일 이내 노출되지 않은 글 조회
    const cutoffDate = getDateBefore(100);
    const availableQuotes = await getAvailableQuotes(cutoffDate);

    if (availableQuotes.length === 0) {
      // 폴백: 가장 오래된 글 재사용
      availableQuotes = await getOldestShownQuotes();
    }

    const selectedQuote = selectWithWeights(availableQuotes);

    // 트랜잭션으로 일관성 보장
    await db.runTransaction(async (t) => {
      t.set(dailyQuoteRef, {
        date: today,
        quote_id: selectedQuote.id,
        selected_at: new Date()
      });

      t.update(quoteRef, {
        last_shown_date: today
      });
    });

  } catch (error) {
    await notifyAdmins('daily_quote_selection_failed', error);
    throw error; // Functions 재시도
  }
});
```

### 🧹 정기 유지보수
```typescript
// 주간 정리 작업
export const weeklyMaintenance = onSchedule('0 2 * * 0', async () => {
  await Promise.allSettled([
    cleanupOldSubmissions(90), // 90일 이상 거절된 제출글 삭제
    optimizeQuoteStats(),      // 통계 최적화
    generateWeeklyReport()     // 주간 리포트
  ]);
});
```

---

## 성능 최적화

### ⚡ 다층 캐싱 전략
```typescript
class CacheService {
  // L1: 메모리 캐시 (5분, 1000개 제한)
  private memoryCache = new Map<string, CacheItem>();

  // L2: Redis 캐시 (1시간)
  private redis = new Redis(process.env.REDIS_URL);

  async get<T>(key: string): Promise<T | null> {
    // 1단계: 메모리 캐시
    const memory = this.memoryCache.get(key);
    if (memory && !this.isExpired(memory)) {
      return memory.value;
    }

    // 2단계: Redis 캐시
    const redis = await this.redis.get(key);
    if (redis) {
      const value = JSON.parse(redis);
      this.setMemoryCache(key, value);
      return value;
    }

    return null;
  }
}
```

### 🔄 배치 처리 최적화
```typescript
// Firestore 읽기 비용 최적화
async getQuotesByIds(ids: string[]): Promise<Map<string, Quote>> {
  // 캐시에서 먼저 확인
  const cached = await this.cacheService.mget(ids.map(id => `quote:${id}`));

  // 캐시에 없는 것만 배치 조회
  const missedIds = ids.filter(id => !cached.has(`quote:${id}`));

  if (missedIds.length > 0) {
    const batchSize = 10; // Firestore 제한
    const batches = chunk(missedIds, batchSize);

    const results = await Promise.all(
      batches.map(batch => this.db.getAll(...batch.map(id =>
        this.db.collection('quotes').doc(id)
      )))
    );

    // 결과를 캐시에 저장
    results.flat().forEach(doc => {
      if (doc.exists) {
        this.cacheService.set(`quote:${doc.id}`, doc.data(), 3600);
      }
    });
  }
}
```

### 📊 응답 압축 및 캐싱
```typescript
// HTTP 레벨 최적화
app.use(compression({
  threshold: 1024,
  level: 6
}));

app.use('/v1/quotes/today', cacheMiddleware(1800)); // 30분 캐싱
```

---

## 에러 처리

### 🚨 구조화된 에러 시스템
```typescript
export class AppError extends Error {
  constructor(
    public code: ErrorCode,
    message: string,
    public statusCode: number,
    public isOperational: boolean = true
  ) {
    super(message);
  }

  toResponse() {
    return {
      error: this.code,
      message: this.message,
      timestamp: new Date().toISOString()
    };
  }
}

// 에러 타입들
export enum ErrorCode {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  INTERNAL_ERROR = 'INTERNAL_ERROR'
}
```

### 📝 구조화된 로깅
```typescript
class Logger {
  // 비즈니스 이벤트
  logBusinessEvent(event: string, data: object) {
    this.winston.info(`Business Event: ${event}`, {
      eventType: 'business',
      eventName: event,
      eventData: data,
      requestId: this.requestId
    });
  }

  // 성능 로깅
  logPerformance(operation: string, duration: number) {
    this.winston.info(`Performance: ${operation}`, {
      eventType: 'performance',
      operation,
      duration,
      requestId: this.requestId
    });
  }
}
```

### 🔔 알림 시스템
```typescript
// 심각한 오류 시 Slack 알림
async notifyAdmins(event: string, data: object) {
  const payload = {
    text: `🚨 Daily Quote Backend Alert`,
    attachments: [{
      color: 'danger',
      fields: [
        {title: 'Event', value: event},
        {title: 'Details', value: JSON.stringify(data)}
      ]
    }]
  };

  await fetch(process.env.SLACK_WEBHOOK_URL, {
    method: 'POST',
    body: JSON.stringify(payload)
  });
}
```

---

## 테스트 전략

### 🧪 테스트 피라미드
```
E2E Tests (10%)     - 전체 워크플로우
Integration (20%)   - API 통합 테스트
Unit Tests (70%)    - 개별 함수/클래스
```

### 🔧 단위 테스트 예시
```typescript
describe('QuoteService', () => {
  let service: QuoteService;
  let mockRepository: jest.Mocked<QuoteRepository>;

  beforeEach(() => {
    mockRepository = createMockRepository();
    service = new QuoteService(mockRepository);
  });

  it('오늘의 글을 캐시에서 반환해야 한다', async () => {
    // Arrange
    mockRepository.getDailyQuote.mockResolvedValue(mockQuote);

    // Act
    const result = await service.getTodaysQuote();

    // Assert
    expect(result).toEqual(mockQuote);
  });
});
```

### 🌐 통합 테스트 예시
```typescript
describe('Quotes API', () => {
  it('오늘의 글을 반환해야 한다', async () => {
    const response = await request(app)
      .get('/v1/quotes/today')
      .expect(200);

    expect(response.body.data).toHaveProperty('content');
    expect(response.headers['cache-control']).toContain('max-age');
  });
});
```

### 📊 품질 메트릭
```json
{
  "coverageThreshold": {
    "global": {
      "branches": 80,
      "functions": 85,
      "lines": 85,
      "statements": 85
    }
  }
}
```

---

## 📈 핵심 설계 결정

| 영역 | 선택 | 이유 |
|------|------|------|
| **아키텍처** | Firebase Functions | 서버리스, 자동 스케일링 |
| **데이터베이스** | Firestore | NoSQL 유연성, 실시간 동기화 |
| **캐싱** | 메모리 + Redis | 다층 캐싱으로 성능 최적화 |
| **에러 처리** | 구조화된 에러 클래스 | 일관된 에러 처리 |
| **로깅** | Winston + 구조화 | 디버깅과 모니터링 최적화 |
| **테스트** | Jest + Supertest | 포괄적 테스트 커버리지 |

## 🚀 확장성 고려사항

- **캐싱 전략**: 다층 캐시로 읽기 성능 극대화
- **배치 처리**: Firestore 비용 최적화
- **에러 복구**: 자동 재시도 및 폴백 메커니즘
- **모니터링**: 성능 및 비즈니스 메트릭 추적
- **품질 보장**: 높은 테스트 커버리지와 자동화
