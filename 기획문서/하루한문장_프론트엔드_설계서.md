# 하루 한 문장 - 프론트엔드 설계서

## 📋 목차
1. [프론트엔드 아키텍처](#프론트엔드-아키텍처)
2. [컴포넌트 설계](#컴포넌트-설계)
3. [상태 관리 전략](#상태-관리-전략)
4. [라우팅 구조](#라우팅-구조)
5. [타입 시스템](#타입-시스템)
6. [폴더 구조](#폴더-구조)
7. [성능 최적화](#성능-최적화)
8. [UI/UX 설계](#uiux-설계)

---

## 프론트엔드 아키텍처

### 🏗️ 기술 스택
- **프레임워크**: React 18 + TypeScript
- **UI 라이브러리**: Material-UI (MUI)
- **빌드 도구**: Vite (빠른 개발 서버, 최적화된 빌드)
- **상태 관리**: Zustand (전역) + TanStack Query (서버 상태)
- **스타일링**: MUI 테마 시스템 + Emotion
- **배포**: Firebase Hosting

### 🎯 아키텍처 원칙
```
📱 사용자 경험 우선
├── 🚀 빠른 로딩 (3초 이내 첫 화면)
├── 📱 모바일 최적화 (모바일 퍼스트)
├── ♿ 접근성 준수 (WCAG 2.1 AA)
└── 🔄 오프라인 지원 (PWA)

🧩 확장 가능한 구조
├── 📦 컴포넌트 재사용성
├── 🔧 타입 안정성
├── 🧪 테스트 용이성
└── 📈 성능 최적화
```

---

## 컴포넌트 설계

### 🎨 Atomic Design 패턴
```
📁 src/components/
├── 🔹 atoms/          # 최소 단위 컴포넌트
│   ├── Button.tsx     # 기본 버튼
│   ├── Input.tsx      # 입력 필드
│   ├── Text.tsx       # 텍스트 표시
│   ├── Icon.tsx       # 아이콘
│   └── Spinner.tsx    # 로딩 스피너
│
├── 🔸 molecules/      # 조합 컴포넌트
│   ├── LikeButton.tsx    # 공감 버튼 + 카운트
│   ├── ShareButton.tsx   # 공유 버튼 + 옵션
│   ├── QuoteText.tsx     # 글귀 + 스타일링
│   └── SubmitInput.tsx   # 제출 입력폼
│
├── 🔷 organisms/      # 복합 컴포넌트
│   ├── QuoteCard.tsx     # 메인 글귀 카드
│   ├── Header.tsx        # 상단 네비게이션
│   ├── SubmissionForm.tsx # 글 제출 폼
│   └── LoadingScreen.tsx # 로딩 화면
│
├── 📄 templates/      # 페이지 레이아웃
│   ├── MainLayout.tsx    # 기본 레이아웃
│   └── CenteredLayout.tsx # 중앙 정렬 레이아웃
│
└── 🏠 pages/          # 페이지 컴포넌트
    ├── HomePage.tsx      # 메인 페이지
    ├── SubmitPage.tsx    # 제출 페이지
    └── AdminPage.tsx     # 관리자 페이지
```

### 🎯 핵심 컴포넌트 상세 설계

#### QuoteCard (메인 글귀 카드)
```typescript
interface QuoteCardProps {
  quote: Quote;
  onLike: () => void;
  onShare: () => void;
  onNext: () => void;
}

const QuoteCard: React.FC<QuoteCardProps> = ({
  quote,
  onLike,
  onShare,
  onNext
}) => {
  return (
    <Card
      sx={{
        minHeight: '400px',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        alignItems: 'center',
        padding: 4,
        borderRadius: 3,
        boxShadow: '0 8px 32px rgba(0,0,0,0.1)'
      }}
    >
      <CardContent>
        <QuoteText content={quote.content} />

        <Box sx={{ mt: 4, display: 'flex', gap: 2, justifyContent: 'center' }}>
          <LikeButton
            count={quote.like_count}
            onClick={onLike}
          />
          <ShareButton
            quote={quote}
            onShare={onShare}
          />
        </Box>

        <Button
          variant="outlined"
          onClick={onNext}
          sx={{ mt: 3 }}
        >
          다른 글 보기
        </Button>
      </CardContent>
    </Card>
  );
};
```

#### LikeButton (공감 버튼)
```typescript
interface LikeButtonProps {
  count: number;
  onClick: () => void;
  disabled?: boolean;
}

const LikeButton: React.FC<LikeButtonProps> = ({
  count,
  onClick,
  disabled = false
}) => {
  const [isAnimating, setIsAnimating] = useState(false);

  const handleClick = () => {
    if (disabled) return;

    setIsAnimating(true);
    onClick();

    setTimeout(() => setIsAnimating(false), 600);
  };

  return (
    <Button
      variant="contained"
      color="primary"
      onClick={handleClick}
      disabled={disabled}
      startIcon={
        <FavoriteIcon
          sx={{
            color: isAnimating ? '#ff4757' : 'inherit',
            transform: isAnimating ? 'scale(1.3)' : 'scale(1)',
            transition: 'all 0.3s ease'
          }}
        />
      }
      sx={{
        px: 3,
        py: 1.5,
        borderRadius: 25,
        textTransform: 'none',
        fontSize: '1.1rem'
      }}
    >
      공감 {count.toLocaleString()}
    </Button>
  );
};
```

---

## 상태 관리 전략

### 🗄️ Zustand를 이용한 전역 상태
```typescript
interface AppStore {
  // UI 상태
  theme: 'light' | 'dark';
  isLoading: boolean;
  snackbar: {
    open: boolean;
    message: string;
    severity: 'success' | 'error' | 'info';
  };

  // 비즈니스 상태
  currentQuote: Quote | null;
  lastFetchTime: number;

  // 액션들
  setTheme: (theme: 'light' | 'dark') => void;
  setLoading: (loading: boolean) => void;
  showSnackbar: (message: string, severity?: 'success' | 'error' | 'info') => void;
  hideSnackbar: () => void;
  setCurrentQuote: (quote: Quote) => void;
}

const useAppStore = create<AppStore>((set) => ({
  // 초기 상태
  theme: 'light',
  isLoading: false,
  snackbar: { open: false, message: '', severity: 'info' },
  currentQuote: null,
  lastFetchTime: 0,

  // 액션 구현
  setTheme: (theme) => set({ theme }),
  setLoading: (isLoading) => set({ isLoading }),
  showSnackbar: (message, severity = 'info') =>
    set({ snackbar: { open: true, message, severity } }),
  hideSnackbar: () =>
    set({ snackbar: { open: false, message: '', severity: 'info' } }),
  setCurrentQuote: (currentQuote) =>
    set({ currentQuote, lastFetchTime: Date.now() }),
}));
```

### 📡 TanStack Query를 이용한 서버 상태
```typescript
// API 호출 함수들
const quoteApi = {
  getTodaysQuote: async (): Promise<Quote> => {
    const response = await fetch('/api/quotes/today');
    if (!response.ok) throw new Error('글을 가져올 수 없습니다');
    return response.json();
  },

  getRandomQuote: async (): Promise<Quote> => {
    const response = await fetch('/api/quotes/random');
    if (!response.ok) throw new Error('글을 가져올 수 없습니다');
    return response.json();
  },

  likeQuote: async (quoteId: string): Promise<{ like_count: number }> => {
    const response = await fetch(`/api/quotes/${quoteId}/like`, {
      method: 'POST'
    });
    if (!response.ok) throw new Error('공감 처리에 실패했습니다');
    return response.json();
  }
};

// React Query 훅들
export const useQuote = () => {
  return useQuery({
    queryKey: ['quote', 'today'],
    queryFn: quoteApi.getTodaysQuote,
    staleTime: 1000 * 60 * 30, // 30분
    cacheTime: 1000 * 60 * 60,  // 1시간
    refetchOnWindowFocus: false,
    retry: 2
  });
};

export const useRandomQuote = () => {
  return useQuery({
    queryKey: ['quote', 'random', Date.now()],
    queryFn: quoteApi.getRandomQuote,
    enabled: false, // 수동으로 실행
    cacheTime: 0     // 캐시하지 않음
  });
};

export const useLikeQuote = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: quoteApi.likeQuote,
    onSuccess: (data, quoteId) => {
      // 로컬 상태 즉시 업데이트 (Optimistic Update)
      queryClient.setQueryData(['quote', 'today'], (old: Quote) =>
        old ? { ...old, like_count: data.like_count } : old
      );
    },
    onError: () => {
      // 에러 시 이전 상태로 롤백
      queryClient.invalidateQueries(['quote', 'today']);
    }
  });
};
```

---

## 라우팅 구조

### 🛣️ React Router 설정
```typescript
const AppRouter: React.FC = () => (
  <BrowserRouter>
    <Suspense fallback={<LoadingScreen />}>
      <Routes>
        <Route path="/" element={<MainLayout />}>
          <Route index element={<HomePage />} />
          <Route path="/submit" element={<SubmitPage />} />
          <Route
            path="/admin"
            element={
              <ProtectedRoute>
                <AdminPage />
              </ProtectedRoute>
            }
          />
        </Route>
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </Suspense>
  </BrowserRouter>
);

// 코드 스플리팅을 위한 레이지 로딩
const HomePage = lazy(() => import('../pages/HomePage'));
const SubmitPage = lazy(() => import('../pages/SubmitPage'));
const AdminPage = lazy(() => import('../pages/AdminPage'));
```

### 🔐 보호된 라우트
```typescript
interface ProtectedRouteProps {
  children: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const [isAuthorized, setIsAuthorized] = useState<boolean | null>(null);

  useEffect(() => {
    // 관리자 권한 확인 로직
    const checkAuth = async () => {
      try {
        const response = await fetch('/api/admin/check');
        setIsAuthorized(response.ok);
      } catch {
        setIsAuthorized(false);
      }
    };

    checkAuth();
  }, []);

  if (isAuthorized === null) {
    return <LoadingScreen />;
  }

  if (!isAuthorized) {
    return <Navigate to="/" replace />;
  }

  return <>{children}</>;
};
```

---

## 타입 시스템

### 📝 도메인 타입 정의
```typescript
// 글 관련 타입
export interface Quote {
  id: string;
  type: 'quote' | 'text';
  content: string;
  like_count: number;
  last_shown_date: string;
  status: 'published' | 'hidden';
  created_at: string;
  updated_at: string;
}

// 제출 관련 타입
export interface Submission {
  id?: string;
  content: string;
  status: 'pending' | 'approved' | 'rejected';
  created_at: string;
  user_ip?: string;
}

// API 응답 타입
export type ApiResponse<T> = {
  data: T;
  error?: string;
  timestamp: string;
};

// 에러 타입
export interface ApiError {
  code: string;
  message: string;
  details?: any;
}
```

### 🎯 컴포넌트 Props 타입
```typescript
// 버튼 컴포넌트 타입
export interface ButtonProps {
  children: React.ReactNode;
  variant?: 'contained' | 'outlined' | 'text';
  color?: 'primary' | 'secondary' | 'error';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  onClick?: () => void;
  startIcon?: React.ReactNode;
  endIcon?: React.ReactNode;
}

// 글귀 카드 Props
export interface QuoteCardProps {
  quote: Quote;
  onLike: () => void;
  onShare: () => void;
  onNext?: () => void;
  showActions?: boolean;
}

// 폼 관련 타입
export interface SubmissionFormData {
  content: string;
}

export interface FormErrors {
  [key: string]: string;
}
```

---

## 폴더 구조

### 📁 Feature-Based 구조
```
📁 frontend/src/
├── 🎯 features/                 # 기능별 모듈
│   ├── quote/                   # 글 관련 기능
│   │   ├── components/
│   │   │   ├── QuoteCard.tsx
│   │   │   ├── QuoteText.tsx
│   │   │   └── QuoteActions.tsx
│   │   ├── hooks/
│   │   │   ├── useQuote.ts
│   │   │   ├── useLikeQuote.ts
│   │   │   └── useRandomQuote.ts
│   │   ├── services/
│   │   │   └── quoteService.ts
│   │   └── types/
│   │       └── quote.types.ts
│   │
│   ├── submission/              # 제출 관련
│   │   ├── components/
│   │   │   ├── SubmissionForm.tsx
│   │   │   └── SubmissionList.tsx
│   │   ├── hooks/
│   │   │   └── useSubmission.ts
│   │   └── services/
│   │       └── submissionService.ts
│   │
│   └── admin/                   # 관리자 기능
│       ├── components/
│       ├── hooks/
│       └── services/
│
├── 🧩 shared/                   # 공통 컴포넌트
│   ├── components/
│   │   ├── atoms/
│   │   │   ├── Button.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Text.tsx
│   │   │   └── Spinner.tsx
│   │   ├── molecules/
│   │   │   ├── LikeButton.tsx
│   │   │   └── ShareButton.tsx
│   │   └── organisms/
│   │       ├── Header.tsx
│   │       └── LoadingScreen.tsx
│   ├── hooks/
│   │   ├── useLocalStorage.ts
│   │   ├── useDebounce.ts
│   │   └── useSnackbar.ts
│   ├── utils/
│   │   ├── formatters.ts
│   │   ├── validators.ts
│   │   └── constants.ts
│   └── types/
│       ├── common.types.ts
│       └── api.types.ts
│
├── 🏠 pages/                    # 페이지 컴포넌트
│   ├── HomePage.tsx
│   ├── SubmitPage.tsx
│   ├── AdminPage.tsx
│   └── NotFoundPage.tsx
│
├── 🎨 styles/                   # 스타일 관련
│   ├── theme.ts                 # MUI 테마
│   ├── globalStyles.ts          # 글로벌 스타일
│   └── animations.ts            # 애니메이션
│
├── 📡 services/                 # 외부 서비스
│   ├── api.ts                   # API 설정
│   ├── firebase.ts              # Firebase 설정
│   └── analytics.ts             # 분석 도구
│
├── 🗄️  store/                   # 상태 관리
│   ├── appStore.ts              # 전역 상태
│   └── queryClient.ts           # React Query 설정
│
├── 📱 App.tsx                   # 앱 엔트리포인트
├── 📄 main.tsx                  # 앱 시작점
└── 🔧 vite-env.d.ts            # Vite 타입 정의
```

---

## 성능 최적화

### ⚡ 코드 스플리팅 & 레이지 로딩
```typescript
// 페이지별 코드 스플리팅
const HomePage = lazy(() =>
  import('../pages/HomePage').then(module => ({
    default: module.HomePage
  }))
);

// 컴포넌트별 레이지 로딩
const HeavyComponent = lazy(() =>
  import('../components/HeavyComponent')
);

// 조건부 로딩
const AdminDashboard = lazy(() =>
  import('../features/admin/AdminDashboard')
);

// 사용 예시
const ConditionalComponent = ({ isAdmin }) => (
  <Suspense fallback={<Spinner />}>
    {isAdmin && <AdminDashboard />}
  </Suspense>
);
```

### 🎯 메모이제이션 전략
```typescript
// React.memo로 불필요한 리렌더링 방지
const QuoteCard = memo<QuoteCardProps>(({
  quote,
  onLike,
  onShare
}) => {
  // 콜백 함수 메모이제이션
  const handleLike = useCallback(() => {
    onLike();
  }, [onLike]);

  const handleShare = useCallback(() => {
    onShare();
  }, [onShare]);

  // 복잡한 계산 메모이제이션
  const formattedContent = useMemo(() => {
    return formatQuoteContent(quote.content);
  }, [quote.content]);

  return (
    <Card>
      <Typography>{formattedContent}</Typography>
      <Button onClick={handleLike}>
        공감 {quote.like_count}
      </Button>
      <Button onClick={handleShare}>공유</Button>
    </Card>
  );
});
```

### 🖼️ 이미지 최적화
```typescript
const OptimizedImage: React.FC<{
  src: string;
  alt: string;
  width?: number;
  height?: number;
}> = ({ src, alt, width, height, ...props }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [error, setError] = useState(false);

  return (
    <Box sx={{ position: 'relative', width, height }}>
      {!isLoaded && !error && (
        <Skeleton
          variant="rectangular"
          width={width}
          height={height}
        />
      )}

      <img
        src={src}
        alt={alt}
        loading="lazy"
        decoding="async"
        onLoad={() => setIsLoaded(true)}
        onError={() => setError(true)}
        style={{
          display: isLoaded ? 'block' : 'none',
          width: '100%',
          height: '100%',
          objectFit: 'cover'
        }}
        {...props}
      />

      {error && (
        <Box
          sx={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            width: '100%',
            height: '100%',
            bgcolor: 'grey.100'
          }}
        >
          <Typography variant="caption" color="text.secondary">
            이미지를 불러올 수 없습니다
          </Typography>
        </Box>
      )}
    </Box>
  );
};
```

### 📊 성능 모니터링
```typescript
// Web Vitals 측정
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    getCLS(onPerfEntry);
    getFID(onPerfEntry);
    getFCP(onPerfEntry);
    getLCP(onPerfEntry);
    getTTFB(onPerfEntry);
  }
};

// Firebase Performance 통합
import { getPerformance, trace } from 'firebase/performance';

const perf = getPerformance();

// 커스텀 성능 트레이스
export const trackQuoteLoad = () => {
  const quoteTrace = trace(perf, 'quote_load');
  quoteTrace.start();

  return {
    stop: () => quoteTrace.stop(),
    addAttribute: (name: string, value: string) =>
      quoteTrace.putAttribute(name, value)
  };
};
```

---

## UI/UX 설계

### 🎨 디자인 시스템
```typescript
// MUI 테마 커스터마이징
const theme = createTheme({
  palette: {
    primary: {
      main: '#2196F3',      // 블루
      light: '#64B5F6',
      dark: '#1976D2'
    },
    secondary: {
      main: '#FF5722',      // 오렌지
      light: '#FF8A65',
      dark: '#E64A19'
    },
    background: {
      default: '#FAFAFA',   // 연한 회색
      paper: '#FFFFFF'
    }
  },
  typography: {
    fontFamily: '"Noto Sans KR", "Roboto", sans-serif',
    h1: {
      fontSize: '2rem',
      fontWeight: 700,
      lineHeight: 1.3
    },
    body1: {
      fontSize: '1.1rem',
      lineHeight: 1.6
    }
  },
  shape: {
    borderRadius: 12
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          fontWeight: 600
        }
      }
    }
  }
});
```

### 📱 반응형 디자인
```typescript
// 브레이크포인트별 스타일
const QuoteContainer = styled(Container)(({ theme }) => ({
  padding: theme.spacing(2),

  [theme.breakpoints.up('sm')]: {
    padding: theme.spacing(3)
  },

  [theme.breakpoints.up('md')]: {
    padding: theme.spacing(4),
    maxWidth: '800px'
  },

  [theme.breakpoints.up('lg')]: {
    maxWidth: '1000px'
  }
}));

// 반응형 글꼴 크기
const QuoteText = styled(Typography)(({ theme }) => ({
  fontSize: '1.2rem',
  textAlign: 'center',
  lineHeight: 1.8,

  [theme.breakpoints.up('sm')]: {
    fontSize: '1.4rem'
  },

  [theme.breakpoints.up('md')]: {
    fontSize: '1.6rem'
  }
}));
```

### ♿ 접근성 (Accessibility)
```typescript
// 키보드 네비게이션 지원
const AccessibleButton: React.FC<ButtonProps> = ({
  children,
  onClick,
  ...props
}) => {
  const handleKeyDown = (event: React.KeyboardEvent) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      onClick?.();
    }
  };

  return (
    <Button
      onClick={onClick}
      onKeyDown={handleKeyDown}
      aria-label={typeof children === 'string' ? children : undefined}
      {...props}
    >
      {children}
    </Button>
  );
};

// 스크린 리더 지원
const QuoteCard: React.FC<QuoteCardProps> = ({ quote, onLike }) => (
  <Card
    component="article"
    role="article"
    aria-label="오늘의 글귀"
  >
    <CardContent>
      <Typography
        variant="h2"
        component="blockquote"
        aria-label={`글귀: ${quote.content}`}
      >
        {quote.content}
      </Typography>

      <Button
        onClick={onLike}
        aria-label={`이 글에 공감하기. 현재 공감 수: ${quote.like_count}`}
      >
        공감 {quote.like_count}
      </Button>
    </CardContent>
  </Card>
);
```

### 🌙 다크 모드 지원
```typescript
// 테마 토글 훅
const useTheme = () => {
  const { theme, setTheme } = useAppStore();

  const toggleTheme = useCallback(() => {
    const newTheme = theme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);
    localStorage.setItem('theme', newTheme);
  }, [theme, setTheme]);

  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as 'light' | 'dark';
    if (savedTheme) {
      setTheme(savedTheme);
    }
  }, [setTheme]);

  return { theme, toggleTheme };
};

// 다크 테마 정의
const darkTheme = createTheme({
  palette: {
    mode: 'dark',
    primary: {
      main: '#90CAF9'
    },
    background: {
      default: '#121212',
      paper: '#1E1E1E'
    }
  }
});
```

---

## 📝 핵심 설계 원칙

### ✅ 사용자 경험 우선
1. **빠른 로딩**: 3초 이내 첫 화면 표시
2. **직관적 인터페이스**: 최소한의 학습으로 사용 가능
3. **모바일 최적화**: 터치 친화적 인터페이스
4. **오프라인 지원**: PWA로 네트워크 단절시에도 기본 기능 제공

### 🔧 개발자 경험 최적화
1. **타입 안정성**: 엄격한 TypeScript 적용
2. **컴포넌트 재사용**: Atomic Design으로 일관성 확보
3. **테스트 용이성**: 의존성 분리와 순수 함수 활용
4. **개발 효율성**: Vite의 HMR과 빠른 빌드 활용

### 📈 확장성 확보
1. **모듈화**: 기능별 독립적 모듈 설계
2. **상태 분리**: 전역/로컬/서버 상태 명확한 구분
3. **성능 최적화**: 코드 스플리팅과 지연 로딩
4. **유지보수성**: 명확한 폴더 구조와 네이밍 규칙

---

이 설계서는 하루 한 문장 프로젝트의 프론트엔드 구현을 위한 상세 가이드라인을 제공합니다. React 생태계의 현대적 패턴을 적용하여 확장 가능하고 유지보수하기 쉬운 구조를 목표로 합니다.